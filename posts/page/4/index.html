<!DOCTYPE html>
<html lang="en" dir=" auto">

<head><script src="/aLong/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=aLong/livereload" data-no-instant defer></script>
</head>

<body class=" list" id="
    top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/aLong/" accesskey="h" title="aLong blog (Alt + H)">aLong blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">golang.org/x/xerrors：undefined: errors.Frame
    </h2>
  </header>
  <div class="entry-content">
    <p>项目初始化遇到问题 错误为：
../go/pkg/mod/golang.org/x/xerrors@v0.0.0-20190410155217-1f06c39b4373/adaptor_go1_13.go:16:14: undefined: errors.Frame ../go/pkg/mod/golang.org/x/xerrors@v0.0.0-20190410155217-1f06c39b4373/format_go1_13.go:12:18: undefined: errors.Formatter exit status 2 exit status 1 通过科普得到一个方法： go get -u golang.org/x/xerrors
问题解决了。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-01-16 19:05:39 +0000 UTC'>2020-01-16</span></footer>
  <a class="entry-link" aria-label="post link to golang.org/x/xerrors：undefined: errors.Frame" href="http://localhost:1313/aLong/posts/golang-org-x-xerrorsundefined-errors-frame/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Golang 环境准备
    </h2>
  </header>
  <div class="entry-content">
    <p>安装GOlang 环境:macOS
shell: zsh
安装步骤： brew update &amp;&amp; brew upgrade # 更新 brew install go # 安装 go 配置环境变量 我的本shell 是zsh 下面是按照zsh配置： 如果需要修改默认的环境变量配置修改 vim ~/.bash_profile 或 vim ~/.zshrc # GOROOT安装的路径 export GOROOT=/usr/local/Cellar/go/1.9/libexec #GOPATH root bin export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN #GOPATH export GOPATH=$HOME/go #GOPATH bin export PATH=$PATH:$GOPATH/bin 退出保存后，使文件生效 source ~/.zshrc= </p>
  </div>
  <footer class="entry-footer"><span title='2020-01-16 18:51:34 +0000 UTC'>2020-01-16</span></footer>
  <a class="entry-link" aria-label="post link to Golang 环境准备" href="http://localhost:1313/aLong/posts/golang-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">yarn install phantomjs-prebuilt: Command failed.
    </h2>
  </header>
  <div class="entry-content">
    <p>项目yarn install 出现phantomjs-prebuilt： Command failed. 自己在项目中发现执行 yarn install时候，一直卡住没走完。
最后报错， error phantomjs-prebuilt： Command failed.
可以看到错误中，他是从 github.com/Medium/… 感觉就是没下载成功吧。
最开始以为网络问题，翻墙等方式都试过后发现还是没完成。
没办法，借助网络得知。可以轻松搞定：
npm config set phantomjs_cdnurl=http://cdn.npm.taobao.org/dis… yarn config set “phantomjs_cdnurl” “https://npm.taobao.org/mirrors/phantomjs&#34;
看你是npm 还是node。按照上面方式设置一下。
rm -rf path/node_moudels
yarn install
解决问题，美滋滋。
引用地址
</p>
  </div>
  <footer class="entry-footer"><span title='2020-01-16 14:21:26 +0000 UTC'>2020-01-16</span></footer>
  <a class="entry-link" aria-label="post link to yarn install phantomjs-prebuilt: Command failed." href="http://localhost:1313/aLong/posts/yarn-install-phantomjs-prebuilt-command-failed/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MySQL5.7修改root密码
    </h2>
  </header>
  <div class="entry-content">
    <p>最近维护一个MySQL数据库，由于各种原因，密码已经不知道了。现在让我在这台服务器上使用里面的MySQL数据库。
怎么办？
首先问了一圈没有人知道。那么只能靠自己了。
查看软件版本: mysql --version
之后通过神奇的Google科普了一下。 知道了具体的方法：
关闭mysql服务。
修改my.conf 在里面[mysqld] 下面最后加入一行
[mysqld] ... skip-grant-tables 修改完保存退出。
重启mysql服务。
mysql 进入mysql 不需要密码了。
show databases; 查看数据库
use mysql; 选择 mysql 数据库 在此数据库执行更新语句（修改root用户的密码为root）： update user set authentication_string=password(&#39;root&#39;) where user=&#39;root&#39;; flush privileges; 更新权限
退出mysql
把最开始my.conf加入的语句删除。
重启mysql服务
最后可以通过设置的密码登陆数据库了。
</p>
  </div>
  <footer class="entry-footer"><span title='2020-01-15 15:23:54 +0000 UTC'>2020-01-15</span></footer>
  <a class="entry-link" aria-label="post link to MySQL5.7修改root密码" href="http://localhost:1313/aLong/posts/mysql5-7%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus-SNMP_Exporter Generator
    </h2>
  </header>
  <div class="entry-content">
    <p>Prometheus-SNMP Exporter 生成器从generator.yml读取并写入snmp.yml。
之前在说Prometheus-snmp_export部署时,没有具体提到snmp.yml的生成器是怎么生成的.几乎用的都是github上的snmp.yml文件(只在demo中添加了auth配置).
因为刚好所有通用的指标都取得通用的mib树. 在后期我搜集设备的信息需要一些私有mib的数据,这时候需要自己通过生成器来生成snmp.yml.
Generator 的操作步骤 下载需要的程序(Docker方式跳过此步骤) # Debian-based distributions. sudo apt-get install unzip build-essential libsnmp-dev # Debian-based distros # Redhat-based distributions. sudo yum install gcc gcc-g&#43;&#43; make net-snmp net-snmp-utils net-snmp-libs net-snmp-devel # RHEL-based distros go get github.com/prometheus/snmp_exporter/generator cd ${GOPATH-$HOME/go}/src/github.com/prometheus/snmp_exporter/generator go build make mibs(不建议直接make) 这里直接make mibs 可能会失败,在make文件里设置的源有些已经不能访问了或执行出现错误.
我建议先下载好mibs ,我已经上传github.
建议自行搜集mib 不执行make mibs会方便一些
把所有的mib放入mibs 目录下.
需要准备好所有需要涉及到的mib文件. 除了公有的mib,我们还需要监控目标设备的私有mib.思科/华为之类的会提供这些mib,像锐捷这种需要和商务部联系.
一些mib:
https://github.com/netdisco/netdisco-mibs
https://github.com/pgmillon/observium/tree/master/mibs
https://github.com/librenms/librenms/tree/master/mibs
当我们准备好所有的mib后,需要编写一个generator.yml. 下面是一个翻译的官方文档(翻译比较烂,自行查阅[原文]([https://github.com/prometheus/snmp\_exporter/tree/master/generator](https://github.com/prometheus/snmp\_exporter/tree/master/generator))):
modules: module_name: # 模块名称。您可以根据需要拥有任意数量的模块。 walk: # 要walk的OID列表。 也可以是SNMP对象名称或特定实例。 - 1.3.6.1.2.1.2 # 与“接口”相同。 - sysUpTime # 与“ 1.3.6.1.2.1.1.3”相同。 - 1.3.6.1.2.1.31.1.1.1.6.40 # 索引为“ 40”的“ ifHCInOctets”的实例。 version: 2 # 要使用的SNMP版本。 默认2。 # 1将使用GETNEXT，2和3将使用GETBULK。 max_repetitions: 25 # 使用GET / GETBULK请求多少个对象，默认为25。 # 对于有故障的设备，可能需要减少。 retries: 3 # 重试失败请求的次数，默认为3。 timeout: 10s # 每次步行的超时时间，默认为10秒。 auth: # 社区字符串与SNMP v1和v2一起使用。 默认为“ public”。 community: public # v3具有不同且更复杂的设置。 # 需要哪些取决于security_level。 # 还列出了NetSNMP命令上的等效选项，例如snmpbulkwalk和snmpget。 # 请参见snmpcmd（1）。 username: user # 必需，无默认值。 NetSNMP的-u选项。 security_level: noAuthNoPriv # 默认为noAuthNoPriv。 NetSNMP的-l选项。 # 可以是noAuthNoPriv，authNoPriv或authPriv。 password: pass # 没有默认值。 也称为authKey，NetSNMP的-A选项。 # 如果security_level是authNoPriv或authPriv，则为必需。 auth_protocol: MD5 # MD5或SHA，默认为MD5。 -NetSNMP的选项。 # 如果security_level为authNoPriv或authPriv，则使用此属性。 priv_protocol: DES # DES或AES，默认为DES。 NetSNMP的-x选项。 # 如果security_level为authPriv，则使用。 priv_password: otherPass # 没有默认值。 也称为privKey，NetSNMP的-X选项。 # 如果security_level是authPriv，则为必需。 context_name: context # 没有默认值。 NetSNMP的-n选项。 # 如果在设备上配置了上下文，则为必需。 lookups: # 要执行的查找的可选列表。 # “keep_source_indexes”的默认值为false。 # 索引必须唯一，才能使用此选项。 # 如果表的索引是bsnDot11EssIndex，则通常是该表结果度量的标签。 # 相反,使用索引查找bsnDot11EssSsid表条目，并使用该值创建一个bsnDot11EssSsid标签。 - source_indexes: [bsnDot11EssIndex] lookup: bsnDot11EssSsid drop_source_indexes: false # 如果为true，则删除此查找的源索引标签。 # 当新索引唯一时，这可以避免标签混乱。 overrides: # 允许每个模块覆盖MIB的位 metricName: ignore: true # 从输出中删除度量。 regex_extracts: Temp: # 将创建一个新的度量，并将其附加到metricName上，成为metricNameTemp。 - regex: &#39;(.*)&#39; # 正则表达式从返回的SNMP walk的值中提取一个值。 value: &#39;$1&#39; # 结果将解析为float64，默认为$1。 Status: - regex: &#39;.*Example&#39; value: &#39;1&#39; - regex: &#39;.*&#39; value: &#39;0&#39; type: DisplayString # 覆盖度量标准类型，可能的类型有： # gauge: 带gauge的整数。 # counter: 带类型计数器的整数。 # OctetString: 一个位字符串，呈现为0xff34。 # DateAndTime: RFC 2579日期和时间字节序列。如果设备没有时区数据，则使用UTC。 # DisplayString: ASCII或UTF-8字符串。 # PhysAddress48: 一个48位的MAC地址，呈现为00:01:02:03:04:ff。 # Float: 一个32位浮点值，带有类型gauge。 # Double: 一个64位浮点值，带有类型gauge。 # InetAddressIPv4: IPv4地址，呈现为1.2.3.4。 # InetAddressIPv6: IPv6地址，呈现为0102:0304:0506:0708:090A:0B0C:0D0E:0F10。 # InetAddress: 每个RFC 4001有一个InetAddress。必须以InetAddressType开头。 # InetAddressMissingSize: 因索引中没有大小而违反RFC 4001第4.1节的InetAddress。 # 必须以InetAddressType开头。 # EnumAsInfo: 为其创建单个时间序列的枚举。适用于恒定值。 # EnumAsStateSet: 每个状态具有时间序列的枚举。适用于可变低基数枚举。 # Bits: 一种RFC2578位结构，它产生一个具有每位时间序列的状态集。 下面提供一个自己编写的generator.yml
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-24 15:26:33 +0000 UTC'>2019-12-24</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus-SNMP_Exporter Generator" href="http://localhost:1313/aLong/posts/prometheus-snmp-exporter-generator/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus告警模板详解
    </h2>
  </header>
  <div class="entry-content">
    <p>目的 之前配置告警之后,可以发送告警信息.但对于数据具体的结构信息,在模板中数据读取都比较懵.原因是不太清除警报都提供了哪些数据,除了我们设置的信息,还有没有其他的信息.
告警数据结构 官方docs
推送数据结构:
Alerts数据 KV数据的处理方式 KV结构很简单,键值对.通过键获取对应的值.下面提供了一些方法处理这种结构的一些方法.
字符串相关方法 警报提供的数据是通过GO模板解析的,GO模板的功能通过GO模板文档可以了解.
下面提供了一些处理字符串的方法:
微信通知的DEMO 上图中是微信接受的通知,下面展示通知模板的代码.
{{- define &#34;_alert_list&#34; -}} {{- range .Alerts.Firing -}} ----------------------- 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ---------结束----------------- {{- end -}} {{- define &#34;_resolve_list&#34; -}} {{- range .Alerts.Resolved -}} ************************** 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} 恢复时间: {{ (.EndsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ************结束***************** {{- end -}} {{- define &#34;wechat.message&#34; -}} {{- if and (gt (len .Alerts.Firing) 0) (gt (len .Alerts.Resolved) 0) -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} ==================================== 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- else -}} {{- if gt (len .Alerts.Firing) 0 -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} {{- end -}} {{- if gt (len .Alerts.Resolved) 0 -}} 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- end -}} {{- end -}} {{- end -}} 其中告警设备 server 这个标签是自定义的.如果没有可以删除此行或根据自己标签定义.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-04 11:51:43 +0000 UTC'>2019-12-04</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus告警模板详解" href="http://localhost:1313/aLong/posts/prometheus%E5%91%8A%E8%AD%A6%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus标签处理&amp;服务发现
    </h2>
  </header>
  <div class="entry-content">
    <p>标签处理的重要性 之前的[配置](https://blog.51ai.vip/2019/10/09/prometueus-yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/中提到了标签的处理,不过由于写的是静态的配置,标签可以自己设置或者不设置都可以.
当使用服务发现之后发现标签处理的重要性提升了更高的级别.
标签处理 - job_name: &#39;node&#39; static_configs: - targets: [&#39;172.16.23.110:9100&#39;,&#39;172.16.23.111:9100&#39;] metric_relable_configs: #通过正则重命名标签 - action: replace #replace替换是默认动作。keep（只参加匹配标签的实例）、drop（不采集匹配正则的实例）、labelkeep\labeldrop(对标签进行过滤处理而非实例)等动作 source_labels: [&#39;job&#39;] #原标签，job是默认就会产生的标签，这里job标签的值是node regex: (.*) #正则匹配，这里匹配job标签内的内容，也就是node replacement: beijing #替换成什么内容，如果写$1就是将正则里读取的值 target_label: idc #把替换内容赋值给idc标签 - action: labeldrop #删除标签 regex: job #把原job标签删除 - job_name: &#39;prometheus&#39; static_configs: - targets: [&#39;localhost:9090&#39;] labels: location: bj3 relabel_configs: - action: replace source_labels: [&#39;job&#39;] regex: (.*) replacement: $1 target_label: server 以上两个例子都是替换标签,job:node中,删除了前job标签,下面的job新增了’server’标签内容取的job内容,但没删除job标签.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-03 15:14:16 +0000 UTC'>2019-12-03</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus标签处理&服务发现" href="http://localhost:1313/aLong/posts/prometheus%E6%A0%87%E7%AD%BE%E5%A4%84%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">M3DB笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>M3DB笔记 前阵子研究prometheus,初期没有考虑存储问题.本地默认存储30天数据.
监控已经折腾完毕,现在需要来处理存储的方案.
通过互联网的科普,发现目前有两个方案可以解决这个问题.
thanos
M3DB
thanos是需要存储云端数据(本地存储官方不推荐).不符合我们的考虑范围内.那就来学习M3DB了.
简介 M3可以在较长的保留时间内可靠地存储大规模指标。为了向更广泛的社区中的其他人提供这些好处，我们决定开放M3平台作为Prometheus的远程存储后端，Prometheus是一种流行的监控和警报解决方案。正如其文档所述，Prometheus的可扩展性和耐用性受到单个节点的限制。 M3平台旨在为Prometheus指标提供安全，可扩展且可配置的多租户的存储。
M3于2015年发布，目前拥有超过66亿个时间序列。 M3每秒聚合5亿个指标，并在全球范围内（使用M3DB）每秒持续存储2000万个度量指标，批量写入将每个指标持久保存到区域中的三个副本。它还允许工程师编写度量策略，告诉M3以更短或更长的保留时间（两天，一个月，六个月，一年，三年，五年等）以特定的粒度（一秒，十秒，一分钟，十分钟等）。这允许工程师和数据科学家使用与定义的存储策略匹配的度量标签（标签），在精细和粗粒度范围内智能地存储不同保留的时间序列。例如，工程师可以选择存储“应用程序”标记为“mobile_api”且“端点”标记为“注册”的所有度量标准，这些标记在10秒粒度下为30天，在一小时粒度下为5年。
相关组件 M3 Coordinator M3 Coordinator是一种服务，用于协调上游系统（如Prometheus和M3DB）之间的读写操作。它还提供了管理API，用于设置和配置M3的不同部分。它是用户可以部署以访问M3DB的优势的桥梁，例如长期存储和与其他监控系统（如Prometheus）的多DC设置。
M3DB M3DB是一个分布式时间序列数据库，提供可扩展存储和时间序列的反向索引。它经过优化，具有成本效益和可靠的实时和长期保留指标存储和索引
M3 Query M3 Query是一种服务，它包含一个分布式查询引擎，用于查询实时和历史指标，支持多种不同的查询语言。它旨在支持低延迟实时查询和可能需要更长时间执行的查询，聚合更大的数据集，用于分析用例
M3 Aggregator M3 Aggregator是一种作为专用度量聚合器运行的服务，它基于存储在etcd中的动态规则提供基于流的下采样。它使用领导者选举和聚合窗口跟踪，利用etcd来管理此状态，从而可靠地为低采样度量标准发送至少一次聚合到长期存储。这提供了成本有效且可靠的下采样和汇总指标。这些功能也存在于M3协调器中，但专用聚合器是分片和复制的，而M3协调器则不需要并且需要谨慎部署和以高可用性方式运行。还有一些工作要使用户更容易访问聚合器，而无需他们编写自己的兼容生产者和消费者。
入门 上面的组件通俗讲:
prometheus 需要通过M3 Coordinator来协调存储与查询到M3DB,prometheus本地存储数据时间与这个没关系.
上面没有提到一个名字etcd服务.此服务推断拓扑\配置功能. 如果db嵌入此服务就称为种子节点SeedNode.
官方提供了一个镜象,里面包含 M3 Coordinator &#43; SeedNode.
拉取镜象:docker pull quay.io/m3db/m3dbnode:latest
启动名为m3db容器:docker run -d -p 7201:7201 -p 7203:7203 -p 9003:9003 --name m3db -v $(pwd)/m3db_data:/var/lib/m3db quay.io/m3db/m3dbnode:latest
该容器的端口为7201（用于管理集群拓扑），端口为7203，Prometheus用来刮除M3DB和M3Coordinator生成的度量，端口9003（用于读取和写入度量）已公开。
这时候m3db已经启动,需要创建一个初始命名空间.官方镜象默认是type:local,namespace:default. 这个可以进入容器查看到配置位置/etc/d3dbnode/m3dbnode.yml.如果我们创建其他命名空间需要在m3coordinator中配置好.
curl -X POST http://localhost:7201/api/v1/database/create -d &#39;{ &#34;type&#34;: &#34;local&#34;, &#34;namespaceName&#34;: &#34;default&#34;, &#34;retentionTime&#34;: &#34;24h&#34; }&#39;
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-11-29 17:41:43 +0000 UTC'>2019-11-29</span></footer>
  <a class="entry-link" aria-label="post link to M3DB笔记" href="http://localhost:1313/aLong/posts/m3db%E7%AC%94%E8%AE%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">网络传输速度测试工具
    </h2>
  </header>
  <div class="entry-content">
    <p>网络传输测试软件 最近公司测试限速,搜集软件发现两款,iperf,LANSpeedTest. iperf,多平台. LANSpeedTest,读写显示,操作简单. 局域网测试传输,优先考虑UDP.
iperf Iperf可以报告带宽,延迟抖动和数据包丢失. 官方文档 安装不写了.跳过
iperf常用参数介绍
-i 2	#表示每2秒显示一次报告 -w 80k	#对于TCP方式，此设置为TCP窗口大小。对于UDP方式，此设置为接受UDP数据包的缓冲区大小，限制可以接受数据包的最大值 -B 192.168.122.1	#绑定到主机的多个地址中的一个。对于客户端来说，这个参数设置了出栈接口。对于服务器端来说，这个参数设置入栈接口。这个参数只用于具有多网络接口的主机。 #在Iperf的UDP模式下，此参数用于绑 定和加入一个多播组。使用范围在224.0.0.0至239.255.255.255的多播地址 #常用客户端参数 -b 100m	#用于udp测试时，设置测试发送的带宽，单位：bit/秒，不设置时默认为：1Mbit/秒 -c #指定服务端ip地址 -d #同时测试上行和下行 -t 10	#设置传输时间，为10秒	-P 5	#指定发起5个线程 UDP测试 服务端 iperf -u -s # -u表示以udp模式运行，-s表示作为服务端, 这里需要设置ip 客户端 iperf -u -c 192.168.100.11 -b 100M -t 60 -i 2 #解释：在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.100.11上传带宽测试，测试时间为60秒 iperf -u -c 192.168.100.11 5M -P 30 -t 6	#客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率 iperf -u -c 192.168.100.11 -b 100M -d -t 60 #以100M为数据发送速率，进行上下行带宽测试 TCP测试 服务端 iperf -s 客户端 iperf -c 192.168.100.11 -t 60	#在tcp模式下，客户端到服务器192.168.100.11上传带宽测试，测试时间为60秒。 iperf -c 192.168.100.11 -P 30 -t 60	#客户端同时向服务器端发起30个连接线程。 iperf -c 192.168.100.11 -d -t 60 -i 2	#进行上下行带宽测试。 测试结果 结果中可以看到: 30秒(-t)的测试,传递数据 70&#43; (-b参数), 监测的带宽约为20M .
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-10-23 17:31:55 +0000 UTC'>2019-10-23</span></footer>
  <a class="entry-link" aria-label="post link to 网络传输速度测试工具" href="http://localhost:1313/aLong/posts/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus-AlertManager警告管理搭建与配置
    </h2>
  </header>
  <div class="entry-content">
    <p>AlertManager AlertManager处理由客户端应用程序（如Prometheus服务器）发送的警报。 它负责重复数据消除、分组，并将它们路由到正确的接收器集成（如电子邮件、PagerDuty或OpsGenie）。 它还负责消除和抑制警报。
通过翻译官方文档可以了解到,AlertManager是负责为Prometheus(本身不会发送警报)发送警报的工具. AlertManager不是简单发送警报,可以消除重复警报,分组,抑制警报功能.并支持多接收器.
Prometheus-&gt;触发定义的警报规则-&gt;AlertManager-&gt;发送警报到指定通知渠道.
为了能让Prometheus发送警报,我们需要:
搭建AlertManager服务. 定义AlertManager通知配置. 定义Prometheus警报规则并引入. 测试警报. 定义通知模板. 定义AlertManager通知配置 global: smtp_smarthost: &#39;smtp.163.com:25&#39; # 邮箱smtp服务器代理 smtp_from: &#39;shitu-0071@163.com&#39; # 发送邮箱名称 resolve_timeout: 5m # 处理超时时间，默认为5min smtp_auth_username: &#39;shitu-0071@163.com&#39; # 邮箱帐户 smtp_auth_password: &#39;******&#39; # 邮箱授权码(注意是授权码,不知道自己查一下) wechat_api_url: &#39;https://qyapi.weixin.qq.com/cgi-bin/&#39; # 企业微信地址 # 定义模板信心 templates: - &#39;template/*.tmpl&#39; # 定义路由树信息 route: group_by: [&#39;alertname&#39;, &#39;cluster&#39;, &#39;service&#39;] # 报警分组依据,设置后会按照设定值分组,例如instance,alertname等 # 同标签警告会在作为一组警报发送 group_wait: 10s # 组内等待时间,触发阈值后,XXs后发送本组警报 group_interval: 10s # 每个组之前间隔时间(group_by设定的值划分的组) repeat_interval: 1m # 重复发送警报的周期 (对于email配置中，此项不可以设置过低，否则将会由于邮件发送太多频繁，被smtp服务器拒绝) receiver: &#39;email&#39; # 发送警报的接收者的名称 # 以下receivers name的名称 routes: - match: # 普通匹配 serverity: critical # 警告级别critical receiver: email # 通过邮件发送 - match_re: # 正则匹配 severity: ^(warning)$ # 匹配警告级别为warning的 receiver: wechat # 通过微信发送告警 - receiver: along # 定义接收者 match: # 匹配 severity: test # 等级为test # 定义警报接收者信息 receivers: - name: &#39;email&#39; # 警报 email_configs: # 邮箱配置 - to: &#39;******@163.com&#39; # 接收警报的email配置 html: &#39;{{ template &#34;test.html&#34; . }}&#39; # 设定邮箱的内容模板 headers: { Subject: &#34;[WARN] 报警邮件&#34;} # 接收邮件的标题 webhook_configs: # webhook配置 - url: &#39;http://127.0.0.1:5001&#39; send_resolved: true - name: &#39;wechat&#39; wechat_configs: # 企业微信报警配置 - send_resolved: true to_party: &#39;1&#39; # 接收组的id agent_id: &#39;1000002&#39; # (企业微信--&gt;自定应用--&gt;AgentId) corp_id: &#39;******&#39; # 企业信息(我的企业--&gt;CorpId[在底部]) api_secret: &#39;******&#39; # 企业微信(企业微信--&gt;自定应用--&gt;Secret) message: &#39;{{ template &#34;test_wechat.html&#34; . }}&#39; # 发送消息模板的设定 # 一个inhibition规则是在与另一组匹配器匹配的警报存在的条件下， # 使匹配一组匹配器的警报失效的规则。两个警报必须具有一组相同的标签。 inhibit_rules: - source_match: severity: &#39;critical&#39; target_match: severity: &#39;critical&#39; equal: [&#39;instance&#39;] # 已经发送的告警通知匹配到target_match和target_match_re规则， # 再有新的告警规则如果满足source_match # 或者定义的匹配规则，并且已发送的告警与新产生的告警中equal定义的标签完全相同， # 则启动抑制机制，新的告警不会发送。 以下是官方文档配置翻译的文档.供参考具体详细的配置介绍.不细看先略过到下个步骤.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-10-19 09:40:15 +0000 UTC'>2019-10-19</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus-AlertManager警告管理搭建与配置" href="http://localhost:1313/aLong/posts/prometheus-alertmanager%E8%AD%A6%E5%91%8A%E7%AE%A1%E7%90%86%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/aLong/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/aLong/posts/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    <footer>
    // ... 其他页脚内容 ...
    <a href="http://localhost:1313/aLong/index.xml">订阅RSS</a>
</footer></body>

</html>