<!DOCTYPE html>
<html lang="en" dir=" auto">

<head><script src="/aLong/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=aLong/livereload" data-no-instant defer></script>
</head>

<body class=" list" id="
    top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/aLong/" accesskey="h" title="aLong blog (Alt + H)">aLong blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    AlertManager
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus告警模板详解
    </h2>
  </header>
  <div class="entry-content">
    <p>目的 之前配置告警之后,可以发送告警信息.但对于数据具体的结构信息,在模板中数据读取都比较懵.原因是不太清除警报都提供了哪些数据,除了我们设置的信息,还有没有其他的信息.
告警数据结构 官方docs
推送数据结构:
Alerts数据 KV数据的处理方式 KV结构很简单,键值对.通过键获取对应的值.下面提供了一些方法处理这种结构的一些方法.
字符串相关方法 警报提供的数据是通过GO模板解析的,GO模板的功能通过GO模板文档可以了解.
下面提供了一些处理字符串的方法:
微信通知的DEMO 上图中是微信接受的通知,下面展示通知模板的代码.
{{- define &#34;_alert_list&#34; -}} {{- range .Alerts.Firing -}} ----------------------- 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ---------结束----------------- {{- end -}} {{- define &#34;_resolve_list&#34; -}} {{- range .Alerts.Resolved -}} ************************** 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} 恢复时间: {{ (.EndsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ************结束***************** {{- end -}} {{- define &#34;wechat.message&#34; -}} {{- if and (gt (len .Alerts.Firing) 0) (gt (len .Alerts.Resolved) 0) -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} ==================================== 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- else -}} {{- if gt (len .Alerts.Firing) 0 -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} {{- end -}} {{- if gt (len .Alerts.Resolved) 0 -}} 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- end -}} {{- end -}} {{- end -}} 其中告警设备 server 这个标签是自定义的.如果没有可以删除此行或根据自己标签定义.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-04 11:51:43 +0000 UTC'>2019-12-04</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus告警模板详解" href="http://localhost:1313/aLong/posts/prometheus%E5%91%8A%E8%AD%A6%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus-AlertManager警告管理搭建与配置
    </h2>
  </header>
  <div class="entry-content">
    <p>AlertManager AlertManager处理由客户端应用程序（如Prometheus服务器）发送的警报。 它负责重复数据消除、分组，并将它们路由到正确的接收器集成（如电子邮件、PagerDuty或OpsGenie）。 它还负责消除和抑制警报。
通过翻译官方文档可以了解到,AlertManager是负责为Prometheus(本身不会发送警报)发送警报的工具. AlertManager不是简单发送警报,可以消除重复警报,分组,抑制警报功能.并支持多接收器.
Prometheus-&gt;触发定义的警报规则-&gt;AlertManager-&gt;发送警报到指定通知渠道.
为了能让Prometheus发送警报,我们需要:
搭建AlertManager服务. 定义AlertManager通知配置. 定义Prometheus警报规则并引入. 测试警报. 定义通知模板. 定义AlertManager通知配置 global: smtp_smarthost: &#39;smtp.163.com:25&#39; # 邮箱smtp服务器代理 smtp_from: &#39;shitu-0071@163.com&#39; # 发送邮箱名称 resolve_timeout: 5m # 处理超时时间，默认为5min smtp_auth_username: &#39;shitu-0071@163.com&#39; # 邮箱帐户 smtp_auth_password: &#39;******&#39; # 邮箱授权码(注意是授权码,不知道自己查一下) wechat_api_url: &#39;https://qyapi.weixin.qq.com/cgi-bin/&#39; # 企业微信地址 # 定义模板信心 templates: - &#39;template/*.tmpl&#39; # 定义路由树信息 route: group_by: [&#39;alertname&#39;, &#39;cluster&#39;, &#39;service&#39;] # 报警分组依据,设置后会按照设定值分组,例如instance,alertname等 # 同标签警告会在作为一组警报发送 group_wait: 10s # 组内等待时间,触发阈值后,XXs后发送本组警报 group_interval: 10s # 每个组之前间隔时间(group_by设定的值划分的组) repeat_interval: 1m # 重复发送警报的周期 (对于email配置中，此项不可以设置过低，否则将会由于邮件发送太多频繁，被smtp服务器拒绝) receiver: &#39;email&#39; # 发送警报的接收者的名称 # 以下receivers name的名称 routes: - match: # 普通匹配 serverity: critical # 警告级别critical receiver: email # 通过邮件发送 - match_re: # 正则匹配 severity: ^(warning)$ # 匹配警告级别为warning的 receiver: wechat # 通过微信发送告警 - receiver: along # 定义接收者 match: # 匹配 severity: test # 等级为test # 定义警报接收者信息 receivers: - name: &#39;email&#39; # 警报 email_configs: # 邮箱配置 - to: &#39;******@163.com&#39; # 接收警报的email配置 html: &#39;{{ template &#34;test.html&#34; . }}&#39; # 设定邮箱的内容模板 headers: { Subject: &#34;[WARN] 报警邮件&#34;} # 接收邮件的标题 webhook_configs: # webhook配置 - url: &#39;http://127.0.0.1:5001&#39; send_resolved: true - name: &#39;wechat&#39; wechat_configs: # 企业微信报警配置 - send_resolved: true to_party: &#39;1&#39; # 接收组的id agent_id: &#39;1000002&#39; # (企业微信--&gt;自定应用--&gt;AgentId) corp_id: &#39;******&#39; # 企业信息(我的企业--&gt;CorpId[在底部]) api_secret: &#39;******&#39; # 企业微信(企业微信--&gt;自定应用--&gt;Secret) message: &#39;{{ template &#34;test_wechat.html&#34; . }}&#39; # 发送消息模板的设定 # 一个inhibition规则是在与另一组匹配器匹配的警报存在的条件下， # 使匹配一组匹配器的警报失效的规则。两个警报必须具有一组相同的标签。 inhibit_rules: - source_match: severity: &#39;critical&#39; target_match: severity: &#39;critical&#39; equal: [&#39;instance&#39;] # 已经发送的告警通知匹配到target_match和target_match_re规则， # 再有新的告警规则如果满足source_match # 或者定义的匹配规则，并且已发送的告警与新产生的告警中equal定义的标签完全相同， # 则启动抑制机制，新的告警不会发送。 以下是官方文档配置翻译的文档.供参考具体详细的配置介绍.不细看先略过到下个步骤.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-10-19 09:40:15 +0000 UTC'>2019-10-19</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus-AlertManager警告管理搭建与配置" href="http://localhost:1313/aLong/posts/prometheus-alertmanager%E8%AD%A6%E5%91%8A%E7%AE%A1%E7%90%86%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"></a>
</article>
    </main>
    <footer>
    // ... 其他页脚内容 ...
    <a href="http://localhost:1313/aLong/index.xml">订阅RSS</a>
</footer></body>

</html>