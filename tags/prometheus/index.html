<!DOCTYPE html>
<html lang="en" dir=" auto">

<head><script src="/aLong/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=aLong/livereload" data-no-instant defer></script>
</head>

<body class=" list" id="
    top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/aLong/" accesskey="h" title="aLong blog (Alt + H)">aLong blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Prometheus
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">docker-compose编排搭建prometheus&#43;grafana&#43;alertmanager&#43;node-exporter&#43;snmp-exporter
    </h2>
  </header>
  <div class="entry-content">
    <p>Docker-compose 目前集成很多Exporter，加上grafana的image-renderer，后面又加上ping-exporter，很多东西加起来发现操作一次docker 很烦啊。
科普之后感觉自己对k8s还有有些发怵的。从简单的一个入手吧，选择了docker-compose。
Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。
安装 安装方式看了一下，我选择直接下载bin文件方式：
curl -L https://get.daocloud.io/docker/compose/releases/download/1.12.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose chmod &#43;x /usr/local/bin/docker-compose``` 通过 docker-compose version 看到版本信息算是安装完成。
编写docker-compose.yml 目录结构： ├── docker-compose.yaml ├── prometheus │ ├── rules │ │ └── *(rules).yaml/json │ ├── nodes │ │ └── *(nodes).yaml │ ├── data │ │ └── ... # 挂载prom的data数据 │ └── prometheus.yaml ├── alertmanager │ ├── templates │ │ └── *.tmpl │ └── alertmanager.yaml ├── grafana │ ├── data │ │ ├── plugins #插件目录 │ │ ├── png │ │ └── grafana.db │ └── grafana.ini ├── snmp(snmp_exporter) │ └── snmp.yml └── blackbox(balck box-exporter) └── blackbox.yml 根据结构编写
...</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-17 13:02:50 +0000 UTC'>2020-11-17</span></footer>
  <a class="entry-link" aria-label="post link to docker-compose编排搭建prometheus&#43;grafana&#43;alertmanager&#43;node-exporter&#43;snmp-exporter" href="http://localhost:1313/aLong/posts/docker-compose%E7%BC%96%E6%8E%92%E6%90%AD%E5%BB%BAprometheus-grafana-alertmanager-node-exporter-snmp-exporter/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus-SNMP_Exporter Generator
    </h2>
  </header>
  <div class="entry-content">
    <p>Prometheus-SNMP Exporter 生成器从generator.yml读取并写入snmp.yml。
之前在说Prometheus-snmp_export部署时,没有具体提到snmp.yml的生成器是怎么生成的.几乎用的都是github上的snmp.yml文件(只在demo中添加了auth配置).
因为刚好所有通用的指标都取得通用的mib树. 在后期我搜集设备的信息需要一些私有mib的数据,这时候需要自己通过生成器来生成snmp.yml.
Generator 的操作步骤 下载需要的程序(Docker方式跳过此步骤) # Debian-based distributions. sudo apt-get install unzip build-essential libsnmp-dev # Debian-based distros # Redhat-based distributions. sudo yum install gcc gcc-g&#43;&#43; make net-snmp net-snmp-utils net-snmp-libs net-snmp-devel # RHEL-based distros go get github.com/prometheus/snmp_exporter/generator cd ${GOPATH-$HOME/go}/src/github.com/prometheus/snmp_exporter/generator go build make mibs(不建议直接make) 这里直接make mibs 可能会失败,在make文件里设置的源有些已经不能访问了或执行出现错误.
我建议先下载好mibs ,我已经上传github.
建议自行搜集mib 不执行make mibs会方便一些
把所有的mib放入mibs 目录下.
需要准备好所有需要涉及到的mib文件. 除了公有的mib,我们还需要监控目标设备的私有mib.思科/华为之类的会提供这些mib,像锐捷这种需要和商务部联系.
一些mib:
https://github.com/netdisco/netdisco-mibs
https://github.com/pgmillon/observium/tree/master/mibs
https://github.com/librenms/librenms/tree/master/mibs
当我们准备好所有的mib后,需要编写一个generator.yml. 下面是一个翻译的官方文档(翻译比较烂,自行查阅[原文]([https://github.com/prometheus/snmp\_exporter/tree/master/generator](https://github.com/prometheus/snmp\_exporter/tree/master/generator))):
modules: module_name: # 模块名称。您可以根据需要拥有任意数量的模块。 walk: # 要walk的OID列表。 也可以是SNMP对象名称或特定实例。 - 1.3.6.1.2.1.2 # 与“接口”相同。 - sysUpTime # 与“ 1.3.6.1.2.1.1.3”相同。 - 1.3.6.1.2.1.31.1.1.1.6.40 # 索引为“ 40”的“ ifHCInOctets”的实例。 version: 2 # 要使用的SNMP版本。 默认2。 # 1将使用GETNEXT，2和3将使用GETBULK。 max_repetitions: 25 # 使用GET / GETBULK请求多少个对象，默认为25。 # 对于有故障的设备，可能需要减少。 retries: 3 # 重试失败请求的次数，默认为3。 timeout: 10s # 每次步行的超时时间，默认为10秒。 auth: # 社区字符串与SNMP v1和v2一起使用。 默认为“ public”。 community: public # v3具有不同且更复杂的设置。 # 需要哪些取决于security_level。 # 还列出了NetSNMP命令上的等效选项，例如snmpbulkwalk和snmpget。 # 请参见snmpcmd（1）。 username: user # 必需，无默认值。 NetSNMP的-u选项。 security_level: noAuthNoPriv # 默认为noAuthNoPriv。 NetSNMP的-l选项。 # 可以是noAuthNoPriv，authNoPriv或authPriv。 password: pass # 没有默认值。 也称为authKey，NetSNMP的-A选项。 # 如果security_level是authNoPriv或authPriv，则为必需。 auth_protocol: MD5 # MD5或SHA，默认为MD5。 -NetSNMP的选项。 # 如果security_level为authNoPriv或authPriv，则使用此属性。 priv_protocol: DES # DES或AES，默认为DES。 NetSNMP的-x选项。 # 如果security_level为authPriv，则使用。 priv_password: otherPass # 没有默认值。 也称为privKey，NetSNMP的-X选项。 # 如果security_level是authPriv，则为必需。 context_name: context # 没有默认值。 NetSNMP的-n选项。 # 如果在设备上配置了上下文，则为必需。 lookups: # 要执行的查找的可选列表。 # “keep_source_indexes”的默认值为false。 # 索引必须唯一，才能使用此选项。 # 如果表的索引是bsnDot11EssIndex，则通常是该表结果度量的标签。 # 相反,使用索引查找bsnDot11EssSsid表条目，并使用该值创建一个bsnDot11EssSsid标签。 - source_indexes: [bsnDot11EssIndex] lookup: bsnDot11EssSsid drop_source_indexes: false # 如果为true，则删除此查找的源索引标签。 # 当新索引唯一时，这可以避免标签混乱。 overrides: # 允许每个模块覆盖MIB的位 metricName: ignore: true # 从输出中删除度量。 regex_extracts: Temp: # 将创建一个新的度量，并将其附加到metricName上，成为metricNameTemp。 - regex: &#39;(.*)&#39; # 正则表达式从返回的SNMP walk的值中提取一个值。 value: &#39;$1&#39; # 结果将解析为float64，默认为$1。 Status: - regex: &#39;.*Example&#39; value: &#39;1&#39; - regex: &#39;.*&#39; value: &#39;0&#39; type: DisplayString # 覆盖度量标准类型，可能的类型有： # gauge: 带gauge的整数。 # counter: 带类型计数器的整数。 # OctetString: 一个位字符串，呈现为0xff34。 # DateAndTime: RFC 2579日期和时间字节序列。如果设备没有时区数据，则使用UTC。 # DisplayString: ASCII或UTF-8字符串。 # PhysAddress48: 一个48位的MAC地址，呈现为00:01:02:03:04:ff。 # Float: 一个32位浮点值，带有类型gauge。 # Double: 一个64位浮点值，带有类型gauge。 # InetAddressIPv4: IPv4地址，呈现为1.2.3.4。 # InetAddressIPv6: IPv6地址，呈现为0102:0304:0506:0708:090A:0B0C:0D0E:0F10。 # InetAddress: 每个RFC 4001有一个InetAddress。必须以InetAddressType开头。 # InetAddressMissingSize: 因索引中没有大小而违反RFC 4001第4.1节的InetAddress。 # 必须以InetAddressType开头。 # EnumAsInfo: 为其创建单个时间序列的枚举。适用于恒定值。 # EnumAsStateSet: 每个状态具有时间序列的枚举。适用于可变低基数枚举。 # Bits: 一种RFC2578位结构，它产生一个具有每位时间序列的状态集。 下面提供一个自己编写的generator.yml
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-24 15:26:33 +0000 UTC'>2019-12-24</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus-SNMP_Exporter Generator" href="http://localhost:1313/aLong/posts/prometheus-snmp-exporter-generator/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus告警模板详解
    </h2>
  </header>
  <div class="entry-content">
    <p>目的 之前配置告警之后,可以发送告警信息.但对于数据具体的结构信息,在模板中数据读取都比较懵.原因是不太清除警报都提供了哪些数据,除了我们设置的信息,还有没有其他的信息.
告警数据结构 官方docs
推送数据结构:
Alerts数据 KV数据的处理方式 KV结构很简单,键值对.通过键获取对应的值.下面提供了一些方法处理这种结构的一些方法.
字符串相关方法 警报提供的数据是通过GO模板解析的,GO模板的功能通过GO模板文档可以了解.
下面提供了一些处理字符串的方法:
微信通知的DEMO 上图中是微信接受的通知,下面展示通知模板的代码.
{{- define &#34;_alert_list&#34; -}} {{- range .Alerts.Firing -}} ----------------------- 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ---------结束----------------- {{- end -}} {{- define &#34;_resolve_list&#34; -}} {{- range .Alerts.Resolved -}} ************************** 告警类型：{{ .Labels.alertname }} 告警主题: {{ .Annotations.summary }} 告警详情: {{ .Annotations.description }} 触发时间: {{ (.StartsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} 恢复时间: {{ (.EndsAt.Add 28800e9).Format &#34;2006-01-02 15:04:05&#34; }} {{ end -}} ************结束***************** {{- end -}} {{- define &#34;wechat.message&#34; -}} {{- if and (gt (len .Alerts.Firing) 0) (gt (len .Alerts.Resolved) 0) -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} ==================================== 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- else -}} {{- if gt (len .Alerts.Firing) 0 -}} 告警数量:{{.Alerts.Firing | len}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_alert_list&#34; . }} {{- end -}} {{- if gt (len .Alerts.Resolved) 0 -}} 告警恢复:{{len .Alerts.Resolved}} 告警设备:{{ .GroupLabels.server}} {{ template &#34;_resolve_list&#34; . }} {{- end -}} {{- end -}} {{- end -}} 其中告警设备 server 这个标签是自定义的.如果没有可以删除此行或根据自己标签定义.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-04 11:51:43 +0000 UTC'>2019-12-04</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus告警模板详解" href="http://localhost:1313/aLong/posts/prometheus%E5%91%8A%E8%AD%A6%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus标签处理&amp;服务发现
    </h2>
  </header>
  <div class="entry-content">
    <p>标签处理的重要性 之前的[配置](https://blog.51ai.vip/2019/10/09/prometueus-yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/中提到了标签的处理,不过由于写的是静态的配置,标签可以自己设置或者不设置都可以.
当使用服务发现之后发现标签处理的重要性提升了更高的级别.
标签处理 - job_name: &#39;node&#39; static_configs: - targets: [&#39;172.16.23.110:9100&#39;,&#39;172.16.23.111:9100&#39;] metric_relable_configs: #通过正则重命名标签 - action: replace #replace替换是默认动作。keep（只参加匹配标签的实例）、drop（不采集匹配正则的实例）、labelkeep\labeldrop(对标签进行过滤处理而非实例)等动作 source_labels: [&#39;job&#39;] #原标签，job是默认就会产生的标签，这里job标签的值是node regex: (.*) #正则匹配，这里匹配job标签内的内容，也就是node replacement: beijing #替换成什么内容，如果写$1就是将正则里读取的值 target_label: idc #把替换内容赋值给idc标签 - action: labeldrop #删除标签 regex: job #把原job标签删除 - job_name: &#39;prometheus&#39; static_configs: - targets: [&#39;localhost:9090&#39;] labels: location: bj3 relabel_configs: - action: replace source_labels: [&#39;job&#39;] regex: (.*) replacement: $1 target_label: server 以上两个例子都是替换标签,job:node中,删除了前job标签,下面的job新增了’server’标签内容取的job内容,但没删除job标签.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-12-03 15:14:16 +0000 UTC'>2019-12-03</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus标签处理&服务发现" href="http://localhost:1313/aLong/posts/prometheus%E6%A0%87%E7%AD%BE%E5%A4%84%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus-AlertManager警告管理搭建与配置
    </h2>
  </header>
  <div class="entry-content">
    <p>AlertManager AlertManager处理由客户端应用程序（如Prometheus服务器）发送的警报。 它负责重复数据消除、分组，并将它们路由到正确的接收器集成（如电子邮件、PagerDuty或OpsGenie）。 它还负责消除和抑制警报。
通过翻译官方文档可以了解到,AlertManager是负责为Prometheus(本身不会发送警报)发送警报的工具. AlertManager不是简单发送警报,可以消除重复警报,分组,抑制警报功能.并支持多接收器.
Prometheus-&gt;触发定义的警报规则-&gt;AlertManager-&gt;发送警报到指定通知渠道.
为了能让Prometheus发送警报,我们需要:
搭建AlertManager服务. 定义AlertManager通知配置. 定义Prometheus警报规则并引入. 测试警报. 定义通知模板. 定义AlertManager通知配置 global: smtp_smarthost: &#39;smtp.163.com:25&#39; # 邮箱smtp服务器代理 smtp_from: &#39;shitu-0071@163.com&#39; # 发送邮箱名称 resolve_timeout: 5m # 处理超时时间，默认为5min smtp_auth_username: &#39;shitu-0071@163.com&#39; # 邮箱帐户 smtp_auth_password: &#39;******&#39; # 邮箱授权码(注意是授权码,不知道自己查一下) wechat_api_url: &#39;https://qyapi.weixin.qq.com/cgi-bin/&#39; # 企业微信地址 # 定义模板信心 templates: - &#39;template/*.tmpl&#39; # 定义路由树信息 route: group_by: [&#39;alertname&#39;, &#39;cluster&#39;, &#39;service&#39;] # 报警分组依据,设置后会按照设定值分组,例如instance,alertname等 # 同标签警告会在作为一组警报发送 group_wait: 10s # 组内等待时间,触发阈值后,XXs后发送本组警报 group_interval: 10s # 每个组之前间隔时间(group_by设定的值划分的组) repeat_interval: 1m # 重复发送警报的周期 (对于email配置中，此项不可以设置过低，否则将会由于邮件发送太多频繁，被smtp服务器拒绝) receiver: &#39;email&#39; # 发送警报的接收者的名称 # 以下receivers name的名称 routes: - match: # 普通匹配 serverity: critical # 警告级别critical receiver: email # 通过邮件发送 - match_re: # 正则匹配 severity: ^(warning)$ # 匹配警告级别为warning的 receiver: wechat # 通过微信发送告警 - receiver: along # 定义接收者 match: # 匹配 severity: test # 等级为test # 定义警报接收者信息 receivers: - name: &#39;email&#39; # 警报 email_configs: # 邮箱配置 - to: &#39;******@163.com&#39; # 接收警报的email配置 html: &#39;{{ template &#34;test.html&#34; . }}&#39; # 设定邮箱的内容模板 headers: { Subject: &#34;[WARN] 报警邮件&#34;} # 接收邮件的标题 webhook_configs: # webhook配置 - url: &#39;http://127.0.0.1:5001&#39; send_resolved: true - name: &#39;wechat&#39; wechat_configs: # 企业微信报警配置 - send_resolved: true to_party: &#39;1&#39; # 接收组的id agent_id: &#39;1000002&#39; # (企业微信--&gt;自定应用--&gt;AgentId) corp_id: &#39;******&#39; # 企业信息(我的企业--&gt;CorpId[在底部]) api_secret: &#39;******&#39; # 企业微信(企业微信--&gt;自定应用--&gt;Secret) message: &#39;{{ template &#34;test_wechat.html&#34; . }}&#39; # 发送消息模板的设定 # 一个inhibition规则是在与另一组匹配器匹配的警报存在的条件下， # 使匹配一组匹配器的警报失效的规则。两个警报必须具有一组相同的标签。 inhibit_rules: - source_match: severity: &#39;critical&#39; target_match: severity: &#39;critical&#39; equal: [&#39;instance&#39;] # 已经发送的告警通知匹配到target_match和target_match_re规则， # 再有新的告警规则如果满足source_match # 或者定义的匹配规则，并且已发送的告警与新产生的告警中equal定义的标签完全相同， # 则启动抑制机制，新的告警不会发送。 以下是官方文档配置翻译的文档.供参考具体详细的配置介绍.不细看先略过到下个步骤.
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-10-19 09:40:15 +0000 UTC'>2019-10-19</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus-AlertManager警告管理搭建与配置" href="http://localhost:1313/aLong/posts/prometheus-alertmanager%E8%AD%A6%E5%91%8A%E7%AE%A1%E7%90%86%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometueus.yml配置文件说明
    </h2>
  </header>
  <div class="entry-content">
    <p>整体配置 prometueus.yml 配置文件注解与说明
global: # 全局配置 scrape_interval: 15s # 默认值为 1m，用于设置每次数据收集的间隔 scrape_timeout: 10s # 默认10s,收集超时时间 evaluation_interval: 15s # 记录规则/告警的执行周期 默认1m external_labels: # 时间序列和警告与外部通信(远程存储/警报灯)时用的外部标签 monitor: &#39;ctmonitor&#39; rule_files: # 指定告警规则文件&amp;记录文件 - &#34;/usr/local/prometheus/rules.yml&#34; alerting: # 告警管理配置 alert_relable_configs: # 修改告警内容 - alertmanagers: # 告警管理起配置 - static_configs: # 静态配置 - targets: # 警告器地址 - 172.16.23.12:9093 # 用于配置 scrape 的 endpoint 配置需要 scrape 的 targets 以及相应的参数 # 抓取(pull)，即监控目标配置。默认只有主机本身的监控配置 scrape_configs: # 抓取配置选项 - job_name: prometheus # 默认情况下分配给刮削度量的作业名称。 scrape_interval: 5s # 从这项工作中获取目标的频率。 scrape_timeout: 3s # 每次获取超时时间 honor_timestamps: true # 默认false, 在获取时是否使用当前的时间戳 metrics_path: /metrics # 从目标获取度量的http资源路径。 scheme: http # static_configs: # 为此作业标记的静态配置目标的列表。 - targets: # 目监控标 - 172.16.23.12:9090 # 设备地址&#43;端口 - job_name: &#39;snmp-10.0.0.1&#39; scrape_interval: 30s scrape_timeout: 20s static_configs: - targets: - 10.0.0.1 # SNMP设备,端口默认5060 metrics_path: /snmp params: module: [if_mib] relabel_configs: # 重定义标签 - source_labels: [__address__] # 需要修改的标签 target_label: __param_target # 改成的标签 - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 172.16.23.12:9117 各部分详解 部分官方文档的译文
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-10-09 15:20:58 +0000 UTC'>2019-10-09</span></footer>
  <a class="entry-link" aria-label="post link to Prometueus.yml配置文件说明" href="http://localhost:1313/aLong/posts/prometueus-yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Prometheus&#43;Grafana安装搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。 2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。Prometheus目前在开源社区相当活跃。 Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。
Prometheus的特点:
多维度数据模型。 灵活的查询语言。 不依赖分布式存储，单个服务器节点是自主的。 通过基于HTTP的pull方式采集时序数据。 可以通过中间网关进行时序列数据推送。 通过服务发现或者静态配置来发现目标服务对象。 支持多种多样的图表和界面展示，比如Grafana等。 架构图 Prometheus服务大致过程： Prometheus 定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。
Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。
Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。
PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。
Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。
Prometheus 支持通过SNMP协议获取mertics数据.通过配置job,利用snmp_export读取设备监控信息.
指标(Metric)类型 Counter 计数器,从数据0开始累计计算. 理想状态会永远增长. 累计计算请求次数等 Gauges 瞬时状态的值. 可以任意变化的数值，适用 CPU 使用率 温度等 Histogram 对一段时间范围内数据进行采样，并对所有数值求和与统计数量、柱状图. 某个时间对某个度量值，分组，一段时间http相应大小，请求耗时的时间。 Summary 同样产生多个指标，分别带有后缀_bucket(仅histogram)、_sum、_count Histogram和Summary都可以获取分位数。 通过Histogram获得分位数，要将直方图指标数据收集prometheus中， 然后用prometheus的查询函数histogram_quantile()计算出来。 Summary则是在应用程序中直接计算出了分位数。 Histograms and summaries中阐述了两者的区别，特别是Summary的的分位数不能被聚合。 注意，这个不能聚合不是说功能上不支持，而是说对分位数做聚合操作通常是没有意义的。 LatencyTipOfTheDay: You can’t average percentiles. Period中对“分位数”不能被相加平均的做了很详细的说明：分位数本身是用来切分数据的，它们的平均数没有同样的分位效果。
主要我们监控用到最上面两种,下面两种类型目前我没有接触,上面这段文字与介绍引用自lijiaocn
安装Prometheus 本次搭建利用docker方式.整体搭建完成需要两个容器.暂不配置告警相关,只做监控数据
前提 搭建位置: /home/aLong/prometheus/
环境:docker19.03.1 需要指定版本请查阅官方文档.
系统:centos7
准备工作 Prometheus的配置文件: prometheus.yml 我们建立在搭建位置的根下: touch prometheus.yml 在配置文件中加入测试演示配置
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-28 16:23:05 +0000 UTC'>2019-08-28</span></footer>
  <a class="entry-link" aria-label="post link to Prometheus&#43;Grafana安装搭建" href="http://localhost:1313/aLong/posts/prometheus-grafana%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BA/"></a>
</article>
    </main>
    <footer>
    // ... 其他页脚内容 ...
    <a href="http://localhost:1313/aLong/index.xml">订阅RSS</a>
</footer></body>

</html>